(window.webpackJsonp=window.webpackJsonp||[]).push([[107],{235:function(v,a,_){"use strict";_.r(a);var s=_(0),e=Object(s.a)({},(function(){var v=this,a=v.$createElement,_=v._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"读书笔记-class类文件的结构（二）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#读书笔记-class类文件的结构（二）"}},[v._v("#")]),v._v(" 读书笔记 - Class类文件的结构（二）")]),v._v(" "),_("Badge",{attrs:{text:"JAVA",vertical:"middle"}}),v._v(" "),_("Badge",{attrs:{text:"2019-04-15",type:"warning",vertical:"middle"}}),v._v(" "),_("h2",{attrs:{id:"概述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[v._v("#")]),v._v(" 概述")]),v._v(" "),_("p",[v._v("计算机只认识0和1，所以我们写的程序需要经编译器翻译成由0和1构成的二进制格式才能由计算机执行”。10多年时间过去了，今天的计算机仍然只能识别0和1，但由于最近10年内虚拟机以及大量建立在虚拟机之上的程序语言如雨后春笋般出现并蓬勃发展，将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。")]),v._v(" "),_("h2",{attrs:{id:"class类文件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#class类文件"}},[v._v("#")]),v._v(" Class类文件")]),v._v(" "),_("ul",[_("li",[v._v("Class文件\n"),_("code",[v._v("Class")]),v._v("文件的数据结构是了解虚拟机的重要基础之一，任何一个"),_("code",[v._v("Class")]),v._v("文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。\n"),_("code",[v._v("Class")]),v._v("文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在"),_("code",[v._v("Class")]),v._v("文件之中，中间没有添加任何分隔符，这使得整个"),_("code",[v._v("Class")]),v._v("文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用"),_("code",[v._v("8位字节")]),v._v("以上空间的数据项时，则会按照高位在前的方式分割成若干个"),_("code",[v._v("8位字节")]),v._v("进行存储。")])]),v._v(" "),_("p",[v._v("根据"),_("code",[v._v("Java")]),v._v("虚拟机规范的规定，"),_("code",[v._v("Class")]),v._v("文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型："),_("code",[v._v("无符号数")]),v._v("和"),_("code",[v._v("表")]),v._v("，后面的解析都要以这两种数据类型为基础，所以这里要先介绍这两个概念。")]),v._v(" "),_("ul",[_("li",[v._v("无符号")])]),v._v(" "),_("p",[v._v("无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。")]),v._v(" "),_("ul",[_("li",[v._v("表")])]),v._v(" "),_("p",[v._v("表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以"),_("code",[v._v("_info")]),v._v("结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。")]),v._v(" "),_("p",[_("code",[v._v("无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的集合。")])]),v._v(" "),_("h2",{attrs:{id:"魔数与class文件的版本"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#魔数与class文件的版本"}},[v._v("#")]),v._v(" 魔数与Class文件的版本")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如gif或者jpeg等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。")])]),v._v(" "),_("li",[_("p",[v._v("紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的版本号），高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。")])]),v._v(" "),_("li",[_("p",[v._v("紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时它还是在Class文件中第一个出现的表类型数据项目。")])])]),v._v(" "),_("h2",{attrs:{id:"常量池"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常量池"}},[v._v("#")]),v._v(" 常量池")]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("概述")]),v._v(" "),_("p",[_("code",[v._v("常量池")]),v._v("中每一项常量都是一个表，截止到"),_("code",[v._v("JDK1.7")]),v._v("共有"),_("code",[v._v("14")]),v._v("种结构各不相同的表结构数据，常量池中主要存放两大类常量："),_("code",[v._v("字面量（Literal）")]),v._v("和"),_("code",[v._v("符号引用（Symbolic References）")]),v._v("。字面量比较接近于"),_("code",[v._v("Java")]),v._v("语言层面的常量概念，如文本字符串、声明为final的常量值等。")]),v._v(" "),_("blockquote",[_("p",[v._v("符号引用则属于编译原理方面的概念，包括了下面三类常量：")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("类和接口的全限定名（Fully Qualified Name）")])]),v._v(" "),_("li",[_("p",[v._v("字段的名称和描述符（Descriptor）")])]),v._v(" "),_("li",[_("p",[v._v("方法的名称和描述符")])])])]),v._v(" "),_("p",[_("code",[v._v("Java")]),v._v("代码在进行"),_("code",[v._v("Javac")]),v._v("编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载"),_("code",[v._v("Class")]),v._v("文件的时候进行动态连接。也就是说，在"),_("code",[v._v("Class")]),v._v("文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。")]),v._v(" "),_("h2",{attrs:{id:"访问标志"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#访问标志"}},[v._v("#")]),v._v(" 访问标志")]),v._v(" "),_("p",[v._v("在"),_("code",[v._v("常量池")]),v._v("结束之后，紧接着的两个字节代表"),_("code",[v._v("访问标志（access_flags）")]),v._v("，这个标志用于识别一些类或者接口层次的访问信息，包括：这个"),_("code",[v._v("Class")]),v._v("是类还是接口；是否定义为"),_("code",[v._v("public")]),v._v("类型；是否定义为"),_("code",[v._v("abstract")]),v._v("类型；如果是类的话，是否被声明为"),_("code",[v._v("final")]),v._v("等。")]),v._v(" "),_("h2",{attrs:{id:"类索引、父类索引与接口索引集合"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类索引、父类索引与接口索引集合"}},[v._v("#")]),v._v(" 类索引、父类索引与接口索引集合")]),v._v(" "),_("p",[v._v("类索引（this_class）和父类索引（super_class）都是一个"),_("code",[v._v("u2")]),v._v("类型的数据，而接口索引集合（interfaces）是一组"),_("code",[v._v("u2")]),v._v("类型的数据的集合，"),_("code",[v._v("Class")]),v._v("文件中由这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了"),_("code",[v._v("java.lang.Object")]),v._v("之外，所有的"),_("code",[v._v("Java")]),v._v("类都有父类，因此除了j"),_("code",[v._v("ava.lang.Object")]),v._v("外，所有"),_("code",[v._v("Java")]),v._v("类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按"),_("code",[v._v("implements")]),v._v("语句（如果这个类本身是一个接口，则应当是"),_("code",[v._v("extends")]),v._v("语句）后的接口顺序从左到右排列在接口索引集合中。")]),v._v(" "),_("h2",{attrs:{id:"字段表集合"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#字段表集合"}},[v._v("#")]),v._v(" 字段表集合")]),v._v(" "),_("p",[v._v("字段表（field_info）用于描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。我们可以想一想在Java中描述一个字段可以包含什么信息？可以包括的信息有：字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。")]),v._v(" "),_("h2",{attrs:{id:"描述符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#描述符"}},[v._v("#")]),v._v(" 描述符")]),v._v(" "),_("p",[v._v("描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示。\n对于数组类型，每一维度将使用一个前置的"),_("code",[v._v("[")]),v._v("字符来描述，如一个定义\n为"),_("code",[v._v("java.lang.String[][]")]),v._v("类型的二维数组，将被记录为："),_("code",[v._v("[[Ljava/lang/String；")]),v._v("，一个整型数组"),_("code",[v._v("int[]")]),v._v("将被记录为"),_("code",[v._v("[I")]),v._v("。")]),v._v(" "),_("hr")],1)}),[],!1,null,null,null);a.default=e.exports}}]);