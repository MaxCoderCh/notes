(window.webpackJsonp=window.webpackJsonp||[]).push([[108],{233:function(a,s,t){"use strict";t.r(s);var n=t(0),e=Object(n.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"读书笔记-类加载的时机（三）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#读书笔记-类加载的时机（三）"}},[a._v("#")]),a._v(" 读书笔记 - 类加载的时机（三）")]),a._v(" "),t("Badge",{attrs:{text:"JAVA",vertical:"middle"}}),a._v(" "),t("Badge",{attrs:{text:"2019-04-15",type:"warning",vertical:"middle"}}),a._v(" "),t("h3",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),t("p",[a._v("类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括："),t("code",[a._v("加载（Loading）")]),a._v("、"),t("code",[a._v("验证（Verification）")]),a._v("、"),t("code",[a._v("准备（Preparation）")]),a._v("、"),t("code",[a._v("解析（Resolution）")]),a._v("、"),t("code",[a._v("初始化（Initialization）")]),a._v("、"),t("code",[a._v("使用（Using）")]),a._v("和"),t("code",[a._v("卸载（Unloading）")]),a._v("7个阶段。其中验证、准备、解析3个部分统称为"),t("code",[a._v("连接（Linking）")]),a._v("，这7个阶段的发生顺序如图所示。\n")]),a._v(" "),t("p",[t("img",{attrs:{src:"/images/pasted-72.png",alt:"upload successful"}})]),a._v(" "),t("p",[a._v("加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。")]),a._v(" "),t("h3",{attrs:{id:"注意点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#注意点"}},[a._v("#")]),a._v(" 注意点")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("加载")]),a._v(" "),t("code",[a._v("Java")]),a._v("虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。")])]),a._v(" "),t("ol",[t("li",[a._v("通过一个类的全限定名来获取定义此类的二进制字节流。")]),a._v(" "),t("li",[a._v("将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。")]),a._v(" "),t("li",[a._v("在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。")])]),a._v(" "),t("ul",[t("li",[t("code",[a._v("验证")]),a._v("\n验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。")])]),a._v(" "),t("ol",[t("li",[t("p",[t("code",[a._v("文件格式验证")]),a._v("\n第一阶段要验证字节流是否符合"),t("code",[a._v("Class")]),a._v("文件格式的规范，并且能被当前版本的虚拟机处理。包括：是否以魔数"),t("code",[a._v("0xCAFEBABE")]),a._v("开头。主、次版本号是否在当前虚拟机处理范围之内。常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。"),t("code",[a._v("CONSTANT_Utf8_info")]),a._v("型的常量中是否有不符合UTF8编码的数据。"),t("code",[a._v("Class")]),a._v("文件中各个部分及文件本身是否有被删除的或附加的其他信息等等。")])]),a._v(" "),t("li",[t("p",[t("code",[a._v("元数据验证")]),a._v("\n第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求,包括：这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。这个类的父类是否继承了不允许被继承的类（被final修饰的类）。如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）等等。")])]),a._v(" "),t("li",[t("p",[t("code",[a._v("字节码验证")]),a._v("\n第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，包括：保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。保证跳转指令不会跳转到方法体以外的字节码指令上等等。")])]),a._v(" "),t("li",[t("p",[t("code",[a._v("符号引用验证")]),a._v("\n最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验,包括：符号引用中通过字符串描述的全限定名是否能找到对应的类。在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问等等。")])])]),a._v(" "),t("ul",[t("li",[t("p",[t("code",[a._v("准备")]),a._v("\n准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。")])]),a._v(" "),t("li",[t("p",[t("code",[a._v("解析")]),a._v("\n解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。")])])]),a._v(" "),t("ol",[t("li",[a._v("类或接口的解析")]),a._v(" "),t("li",[a._v("字段解析")]),a._v(" "),t("li",[a._v("类方法解析")]),a._v(" "),t("li",[a._v("接口方法解析")])]),a._v(" "),t("ul",[t("li",[t("code",[a._v("初始化")]),a._v("\n虚拟机规范则是严格规定了"),t("code",[a._v("有且只有5种")]),a._v("情况必须立即对类进行"),t("code",[a._v("初始化")]),a._v("。")])]),a._v(" "),t("ol",[t("li",[a._v("遇到"),t("code",[a._v("new")]),a._v("、"),t("code",[a._v("getstatic")]),a._v("、"),t("code",[a._v("putstatic")]),a._v("或"),t("code",[a._v("invokestatic")]),a._v("这"),t("code",[a._v("4")]),a._v("条"),t("code",[a._v("字节码指令")]),a._v("时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用"),t("code",[a._v("new")]),a._v("关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。")]),a._v(" "),t("li",[a._v("使用"),t("code",[a._v("java.lang.reflect")]),a._v("包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。")]),a._v(" "),t("li",[a._v("当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。")]),a._v(" "),t("li",[a._v("当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类。")]),a._v(" "),t("li",[a._v("当使用"),t("code",[a._v("JDK1.7")]),a._v("的动态语言支持时，如果一个"),t("code",[a._v("java.lang.invoke.MethodHandle")]),a._v("实例最后的解析结果"),t("code",[a._v("REF_getStatic")]),a._v("、"),t("code",[a._v("REF_putStatic")]),a._v("、"),t("code",[a._v("REF_invokeStatic")]),a._v("的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。")])]),a._v(" "),t("p",[a._v("对于这5种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语："),t("code",[a._v("有且只有")]),a._v("，这5种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。")]),a._v(" "),t("h3",{attrs:{id:"双亲委派模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派模型"}},[a._v("#")]),a._v(" 双亲委派模型")]),a._v(" "),t("ul",[t("li",[t("p",[t("code",[a._v("概念")]),a._v("\n双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。")])]),a._v(" "),t("li",[t("p",[t("code",[a._v("过程")]),a._v("\n双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。")])]),a._v(" "),t("li",[t("p",[t("code",[a._v("优点")]),a._v("\n使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。")])])]),a._v(" "),t("h3",{attrs:{id:"常见引用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见引用"}},[a._v("#")]),a._v(" 常见引用")]),a._v(" "),t("ul",[t("li",[t("p",[t("code",[a._v("符号引用（Symbolic References）")]),a._v("\n符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。")])]),a._v(" "),t("li",[t("p",[t("code",[a._v("直接引用（Direct References）")]),a._v("\n直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。")])]),a._v(" "),t("li",[t("p",[t("code",[a._v("被动引用")])])]),a._v(" "),t("li",[t("p",[t("code",[a._v("被动引用代码")])])])]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("package")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("org"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("fenixsoft"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("classloading")]),a._v("；\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/**\n*被动使用类字段演示一：\n*通过子类引用父类的静态字段，不会导致子类初始化\n**/")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SuperClass")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("println（"),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"SuperClass init！"')]),a._v("）；\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" value"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("123")]),a._v("；\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SubClass")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("extends")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SuperClass")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("println（"),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"SubClass init！"')]),a._v("）；\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/**\n*非主动使用类字段演示\n**/")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("NotInitialization")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" main（"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("args）"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("println（"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SubClass")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("value）；\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("ul",[t("li",[t("code",[a._v("输出结果")])])]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[a._v("SuperClass init！\n\n")])])]),t("ul",[t("li",[t("code",[a._v("分析")]),a._v("\n上述代码运行之后，只会输出"),t("code",[a._v("SuperClass init！")]),a._v("，而不会输出"),t("code",[a._v("SubClass init！")]),a._v("。对于静\n态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静\n态字段，只会触发父类的初始化而不会触发子类的初始化。至于是否要触发子类的加载和验\n证，在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。对于"),t("code",[a._v("Sun HotSpot")]),a._v("虚拟机\n来说，可通过"),t("code",[a._v("-XX：+TraceClassLoading")]),a._v("参数观察到此操作会导致子类的加载。")])]),a._v(" "),t("hr")],1)}),[],!1,null,null,null);s.default=e.exports}}]);