(window.webpackJsonp=window.webpackJsonp||[]).push([[111],{227:function(t,s,a){"use strict";a.r(s);var e=a(0),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"京东面试题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#京东面试题"}},[t._v("#")]),t._v(" 京东面试题")]),t._v(" "),a("h2",{attrs:{id:"如何选择arraylist，linkedlist"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何选择arraylist，linkedlist"}},[t._v("#")]),t._v(" 如何选择ArrayList，LinkedList "),a("Badge",{attrs:{text:"一面",type:"warning"}})],1),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[t._v("ArrayList数据结构是数组，LinkedList数据结构是链表。")]),t._v(" "),a("li",[t._v("对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。")]),t._v(" "),a("li",[t._v("对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。")]),t._v(" "),a("li",[t._v("ArrayList支持动态扩容默认原容量的1.5倍，LinkedList是链表并且实现了栈和队列的相关方法，不存在扩容问题。")])])]),t._v(" "),a("h2",{attrs:{id:"arraylist会如何进行扩容呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#arraylist会如何进行扩容呢"}},[t._v("#")]),t._v(" ArrayList会如何进行扩容呢")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("ArrayList 的内部实现，其实是用一个对象数组进行存放具体的值，然后用一种扩容的机制，进行数组的动态增长。\n其扩容机制可以理解为，如果元素的个数，大于其容量，则把其容量扩展为原来容量的1.5倍。")])]),t._v(" "),a("h2",{attrs:{id:"jdk中arrays里sort方法默认是什么排序算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jdk中arrays里sort方法默认是什么排序算法"}},[t._v("#")]),t._v(" JDK中Arrays里sort方法默认是什么排序算法")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("JDK1.8中的"),a("code",[t._v("Arrays.sort()")]),t._v("的排序方法就是使用的快排，当待排序数量大于286的时候，看连续升序和降序性好不好，好则归并，否则快速；当待排序数量小于286的时候，如果待排序数据量大于47的时候采用快速排序，小于47的时候使用插入排序。")])]),t._v(" "),a("h2",{attrs:{id:"jvm中是怎么判断对象可回收的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm中是怎么判断对象可回收的"}},[t._v("#")]),t._v(" JVM中是怎么判断对象可回收的")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("GC ROOT可达性分析")])]),t._v(" "),a("h2",{attrs:{id:"jvm中垃圾收集有哪些算法，各自的特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm中垃圾收集有哪些算法，各自的特点"}},[t._v("#")]),t._v(" JVM中垃圾收集有哪些算法，各自的特点")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[t._v("标记-清除")]),t._v(" "),a("li",[t._v("标记-整理")]),t._v(" "),a("li",[t._v("复制算法")])])]),t._v(" "),a("h2",{attrs:{id:"线程池的创建参数和对线程行为的影响"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程池的创建参数和对线程行为的影响"}},[t._v("#")]),t._v(" 线程池的创建参数和对线程行为的影响")]),t._v(" "),a("blockquote",[a("p",[t._v("请概述线程池的创建参数和对线程行为的影响，怎么样合理配置一个线程池的参数？")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("blockquote",[a("p",[t._v("线程池的创建参数")])]),t._v(" "),a("ul",[a("li",[t._v("corePoolSize：核心线程数量。")]),t._v(" "),a("li",[t._v("maximumPoolSize：最大线程数量。")]),t._v(" "),a("li",[t._v("workQueue：阻塞队列，会对线程运行过程产生重大影响。")])]),t._v(" "),a("blockquote",[a("p",[t._v("参数对线程行为的影响")])]),t._v(" "),a("ul",[a("li",[t._v("当前运行的线程数小于corePoolSize时，直接创建新线程处理任务，即使其他线程空闲。")]),t._v(" "),a("li",[t._v("当corePoolSize  <= 当前线程数 <= maximunPoolSize ，只有当workQueue满的时候才创建新的线程处理任务。")]),t._v(" "),a("li",[t._v("当corePoolSize = maximumPoolSize时，创建的线程池大小是固定的，如果有新任务提交，当workQueue没满的时候，将请求放入workQueue，等待线程空闲后去取出任务进行处理，如果满了，还有新任务提交，则通过拒绝策略参数来指定策略去处理任务。")]),t._v(" "),a("li",[t._v("workQueue是线程池中保存等待执行的任务的阻塞队列，当提交新任务到线程池后，线程池会根据当前线程池中正在运行的线程数量，决定该任务的处理方式，总共有3种：直接切换，用无界队列，用有界队列。")])])]),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("扩展阅读")]),t._v(" "),a("p",[t._v("如果要想降低系统资源的消耗（包括CPU的使用率，操作系统资源的消耗，上下文环境切换的开销等），可以设置较大的队列容量和较小的线程池容量，但这样也会降低线程处理任务的吞吐量。")]),t._v(" "),a("p",[t._v("如果提交的任务经常发生堵塞，那么可以考虑通过调用setMaximunPoolSize（）方法来重新设定线程池容量。如果队列的容量设置的太小，通常需要将线程池的容量设置大一点，这样CPU的使用率会相对的高一鞋。但如果线程池的容量设置的过大，则在提交的任务数量太多的情况下，并发量会增加，那么线程之间的调度就是一个要考虑的问题，因为这样反而有可能降低处理任务的吞吐量。")])]),t._v(" "),a("h2",{attrs:{id:"tcp的三次握手过程，为什么需要三次"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp的三次握手过程，为什么需要三次"}},[t._v("#")]),t._v(" TCP的三次握手过程，为什么需要三次")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("网络不稳定等外界原因会导致消息阻塞，因此需要三次即A再次发送确认收到B消息的握手过程。")])]),t._v(" "),a("h2",{attrs:{id:"查询优化的基本思路是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#查询优化的基本思路是什么"}},[t._v("#")]),t._v(" 查询优化的基本思路是什么")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[t._v("索引的优化")]),t._v(" "),a("li",[t._v("Explain执行计划")]),t._v(" "),a("li",[t._v("慢SQL查询优化")]),t._v(" "),a("li",[t._v("SQL语句的优化")]),t._v(" "),a("li",[t._v("MySQL自身连接参数的优化，缓冲区大小设置等")])])]),t._v(" "),a("h2",{attrs:{id:"索引优化的几点原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引优化的几点原则"}},[t._v("#")]),t._v(" 索引优化的几点原则")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("负向条件查询不能使用索引。")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#负向条件查询")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("order")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("status")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("and")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("status")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#可以优化为 in 查询：")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("order")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" id "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("not")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("in")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("not")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("exists")]),t._v(" \n")])])])]),t._v(" "),a("li",[a("p",[t._v("前导模糊查询不能使用索引，而非前导模糊查询则可以。")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#前导模糊查询，不走索引")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("order")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("desc")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("like")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'%XX'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#非前导模糊查询，正常索引")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("order")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("desc")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("like")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'XX%'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n")])])])]),t._v(" "),a("li",[a("p",[t._v("数据区分度不大的字段不宜使用索引，如：性别。")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("user")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" sex"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n")])])]),a("blockquote",[a("p",[t._v("原因：性别只有男，女，每次过滤掉的数据很少，不宜使用索引。")])])]),t._v(" "),a("li",[a("p",[t._v("在属性上进行计算不能命中索引，可优化为值计算。")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("order")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("YEAR")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("date")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2017'")]),t._v("；\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#可以优化为值计算：")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("order")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("date")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" CURDATE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("；\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("order")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("date")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2017-01-01'")]),t._v("；\n\n")])])])]),t._v(" "),a("li",[a("p",[t._v("如果业务大部分是单条查询，使用Hash索引性能更好，例如用户中心：")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("user")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" uid"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("?\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("user")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" login_name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("?\n")])])]),a("blockquote",[a("p",[t._v("原因：B-Tree 索引的时间复杂度是 O(log(n))；Hash 索引的时间复杂度是 O(1)")])])]),t._v(" "),a("li",[a("p",[t._v("复合索引最左前缀，并不是值 SQL 语句的 where 顺序要和复合索引一致\n用户中心建立了(login_name, passwd)的复合索引")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#都能够命中索引")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("user")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" login_name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("? "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("and")]),t._v(" passwd"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("?\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("user")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" passwd"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("? "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("and")]),t._v(" login_name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("?\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#命中索引，满足复合索引最左前缀")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("user")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" login_name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("?\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#不能命中索引，不满足复合索引最左前缀")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("user")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" passwd"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("?\n")])])])]),t._v(" "),a("li",[a("p",[t._v("使用 ENUM 而不是字符串。")])]),t._v(" "),a("li",[a("p",[t._v("如果明确知道只有一条结果返回，limit 1 能够提高效率。")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#只有一条结果返回")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("user")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" login_name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("?\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#可以优化为")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("user")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" login_name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("? "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("limit")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n")])])]),a("blockquote",[a("p",[t._v("原因：你知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动。")])])]),t._v(" "),a("li",[a("p",[t._v("强制类型转换会全表扫描。")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("user")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" phone"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("13800001234")]),t._v("\n")])])])])])]),t._v(" "),a("h2",{attrs:{id:"为什么需要代理模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要代理模式"}},[t._v("#")]),t._v(" 为什么需要代理模式  "),a("Badge",{attrs:{text:"二面",type:"warning"}})],1),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("在请求之前或者请求之后进行一些额外的工作，又不想业务类做一些不相关的处理，因此需要代理类来完成，包括对业务做一些增强处理等等")])]),t._v(" "),a("h2",{attrs:{id:"讲讲静态代理模式的优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#讲讲静态代理模式的优缺点"}},[t._v("#")]),t._v(" 讲讲静态代理模式的优缺点")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("静态代理虽然效率较高，但是代理对象和被代理对象都实现的一个接口，而这些代理类中的代码几乎是一致的。这在大型系统中将会产生很大的维护问题。")])]),t._v(" "),a("h2",{attrs:{id:"mybatis二级缓存基于哪种设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mybatis二级缓存基于哪种设计模式"}},[t._v("#")]),t._v(" mybatis二级缓存基于哪种设计模式")]),t._v(" "),a("blockquote",[a("p",[t._v("mybatis中在配置二级缓存的时候，可以配置缓存淘汰策略，缓存大小、失效时间、是否加同步控制、是否进行同步控制等附加功能，请问基于什么设计模式实现的")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")])]),t._v(" "),a("h2",{attrs:{id:"说出几个在jdk库中使用的设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说出几个在jdk库中使用的设计模式"}},[t._v("#")]),t._v(" 说出几个在JDK库中使用的设计模式")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[a("strong",[a("code",[t._v("创建型模式:")])])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("抽象工厂模式(AbstractFactory)")]),t._v("，创建一组有关联的对象实例。")]),t._v(" "),a("ul",[a("li",[t._v("java.sql.DriverManager#getConnection()")]),t._v(" "),a("li",[t._v("java.sql.Connection#createStatement()")]),t._v(" "),a("li",[t._v("java.sql.Statement#executeQuery()")]),t._v(" "),a("li",[t._v("java.util.Calendar#getInstance()")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("建造者模式(Builder)")]),t._v("，主要用来简化一个复杂的对象的创建。")]),t._v(" "),a("ul",[a("li",[t._v("java.lang.StringBuilder#append()")]),t._v(" "),a("li",[t._v("java.lang.StringBuffer#append()")]),t._v(" "),a("li",[t._v("java.sql.PreparedStatement")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("工厂方法模式(FactoryMethod)")]),t._v("，简单来说，按照需求返回一个类型的实例。")]),t._v(" "),a("ul",[a("li",[t._v("java.lang.Proxy#newProxyInstance()")]),t._v(" "),a("li",[t._v("java.lang.Object#toString()")]),t._v(" "),a("li",[t._v("java.lang.Class#newInstance()")]),t._v(" "),a("li",[t._v("java.lang.reflect.Array#newInstance()")]),t._v(" "),a("li",[t._v("java.lang.Boolean#valueOf(String)")]),t._v(" "),a("li",[t._v("java.lang.Class#forName()")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("原型模式(Prototype)")]),t._v("，使用自己的实例创建另一个实例(或把已有实例的值拷贝过去)。")]),t._v(" "),a("ul",[a("li",[t._v("java.lang.Object#clone()")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("单例模式 (Singleton)")]),t._v("，只允许一个实例。")]),t._v(" "),a("ul",[a("li",[t._v("java.lang.Runtime#getRuntime()")])])])]),t._v(" "),a("p",[a("strong",[a("code",[t._v("结构型模式:")])])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("适配器模式(Adapter)")]),t._v("，使不兼容的接口相互兼容。")]),t._v(" "),a("ul",[a("li",[t._v("java.io.InputStreamReader(InputStream)")]),t._v(" "),a("li",[t._v("java.io.OutputStreamWriter(OutputStream)")]),t._v(" "),a("li",[t._v("java.util.Arrays#asList()")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("组合模式(Composite)")]),t._v("，一致地对待组合对象和独立对象。\n— org.w3c.dom")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("外观模式(Façade)")]),t._v("，封装一组交互类，一致地对外提供接口。")]),t._v(" "),a("ul",[a("li",[t._v("java.util.logging包")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("装饰模式(Decorator)")]),t._v("，为类添加新的功能；防止类继承带来的过度增长。")]),t._v(" "),a("ul",[a("li",[t._v("java.io包")]),t._v(" "),a("li",[t._v("java.util.Collections#synchronizedList(List)")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("代理模式(Proxy)")]),t._v("，透明调用被代理对象，无须知道复杂实现细节。")]),t._v(" "),a("ul",[a("li",[t._v("java.lang.reflect.Proxy")]),t._v(" "),a("li",[t._v("RMI")])])])]),t._v(" "),a("p",[a("strong",[a("code",[t._v("行为型模式:")])])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("职责链模式(Chain of responsibility)")]),t._v("，把一个对象在一个链接传递直到被处理。")]),t._v(" "),a("ul",[a("li",[t._v("java.util.logging.Logger#log()")]),t._v(" "),a("li",[t._v("javax.servlet.Filter#doFilter()")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("命令模式(Command)")]),t._v("，把一个或一些命令封装到一个对象中。")]),t._v(" "),a("ul",[a("li",[t._v("java.lang.Runnable")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("解释器模式(Interpreter)")]),t._v("，用一组类代表某一规则。")]),t._v(" "),a("ul",[a("li",[t._v("java.util.regex.Pattern")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("迭代器模式(Iterator Pattern)")]),t._v("，用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。")]),t._v(" "),a("ul",[a("li",[t._v("java.util.Iterator")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("中介者模式(Mediator)")]),t._v("，定义一个中介对象来封装一系列对象之间的交互，使原有对象之间耦合松散。")]),t._v(" "),a("ul",[a("li",[t._v("java.util.Timer")]),t._v(" "),a("li",[t._v("java.util.concurrent.Executor#execute(Runnable command)")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("备忘录模式(Memento)")]),t._v("，保持对象状态，需要时可恢复")]),t._v(" "),a("ul",[a("li",[t._v("java.util.Date")]),t._v(" "),a("li",[t._v("java.io.Serializable")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("观察者模式(Observer)")]),t._v("，通知对象状态改变。")]),t._v(" "),a("ul",[a("li",[t._v("java.util.Observer")]),t._v(" "),a("li",[t._v("java.util.Observable")]),t._v(" "),a("li",[t._v("java.util.EventListener 的所有子类")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("策略模式(Strategy)")]),t._v("，提供不同的算法。")]),t._v(" "),a("ul",[a("li",[t._v("java.util.Comparator#compare()")]),t._v(" "),a("li",[t._v("javax.servlet.http.HttpServlet")]),t._v(" "),a("li",[t._v("javax.servlet.Filter#doFilter()")]),t._v(" "),a("li",[t._v("ThreadPoolExecutor中的四种拒绝策略")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("模板方法模式(Template Method)")]),t._v("，定义算法的结构，子类只实现不同的部分(钩子方法)")]),t._v(" "),a("ul",[a("li",[t._v("java.io.InputStream 的所有非抽象方法")]),t._v(" "),a("li",[t._v("java.io.OutputStream 的所有非抽象方法")]),t._v(" "),a("li",[t._v("java.io.Reader 的所有非抽象方法")]),t._v(" "),a("li",[t._v("java.io.Writer 的所有非抽象方法")]),t._v(" "),a("li",[t._v("java.util.AbstractList 的所有非抽象方法")]),t._v(" "),a("li",[t._v("java.util.AbstractSet 的所有非抽象方法")]),t._v(" "),a("li",[t._v("java.util.AbstractMap 的所有非抽象方法")]),t._v(" "),a("li",[t._v("javax.servlet.http.HttpServlet#do开头的方法")])])])])]),t._v(" "),a("h2",{attrs:{id:"请简单谈谈redis-持久化机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请简单谈谈redis-持久化机制"}},[t._v("#")]),t._v(" 请简单谈谈Redis 持久化机制")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("RDB")]),t._v(" "),a("p",[t._v("RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。RDB是Redis默认的持久化方式，会在对应的目录下生产一个dump.rdb文件，重启会通过加载dump.rdb文件恢复数据。")])]),t._v(" "),a("li",[a("p",[t._v("AOF")]),t._v(" "),a("p",[t._v("AOF持久化是以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，文件中可以看到详细的操作记录。她的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。")])])])]),t._v(" "),a("h2",{attrs:{id:"redis的缓存失效策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis的缓存失效策略"}},[t._v("#")]),t._v(" Redis的缓存失效策略")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("当缓存需要被清理时（比如空间占用已经接近临界值了），需要使用某种淘汰算法来决定清理掉哪些数据。常用的淘汰算法有下面几种：")]),t._v(" "),a("ul",[a("li",[t._v("FIFO：First In First Out，先进先出。判断被存储的时间，离目前最远的数据优先被淘汰。")]),t._v(" "),a("li",[t._v("LRU：Least Recently Used，最近最少使用。判断最近被使用的时间，目前最远的数据优先被淘汰。")]),t._v(" "),a("li",[t._v("LFU：Least Frequently Used，最不经常使用。在一段时间内，数据被使用次数最少的，优先被淘汰。")])])]),t._v(" "),a("h2",{attrs:{id:"如何使用redis实现分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何使用redis实现分布式锁"}},[t._v("#")]),t._v(" 如何使用Redis实现分布式锁")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("分布式锁一般有三种实现方式：1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁。")]),t._v(" "),a("p",[t._v("Redis的分布式锁")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RedisTool")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" LOCK_SUCCESS "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"OK"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" SET_IF_NOT_EXIST "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"NX"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" SET_WITH_EXPIRE_TIME "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"PX"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n     * 尝试获取分布式锁\n     * @param jedis Redis客户端\n     * @param lockKey 锁\n     * @param requestId 请求标识\n     * @param expireTime 超期时间\n     * @return 是否获取成功\n     */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryGetDistributedLock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Jedis")]),t._v(" jedis"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" lockKey"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" requestId"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" expireTime"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" result "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" jedis"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("set")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("lockKey"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" requestId"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" SET_IF_NOT_EXIST"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" SET_WITH_EXPIRE_TIME"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" expireTime"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("LOCK_SUCCESS"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("equals")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("result"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("ul",[a("li",[a("p",[t._v("第一个为key，我们使用key来当锁，因为key是唯一的。")])]),t._v(" "),a("li",[a("p",[t._v("第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。")])]),t._v(" "),a("li",[a("p",[t._v("第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；")])]),t._v(" "),a("li",[a("p",[t._v("第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。")])]),t._v(" "),a("li",[a("p",[t._v("第五个为time，与第四个参数相呼应，代表key的过期时间。")])])]),t._v(" "),a("p",[t._v("总的来说，执行上面的set()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。")])]),t._v(" "),a("h2",{attrs:{id:"什么是缓存雪崩，如何解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是缓存雪崩，如何解决"}},[t._v("#")]),t._v(" 什么是缓存雪崩，如何解决")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩。\n造成缓存雪崩的常见业务场景：")]),t._v(" "),a("ul",[a("li",[t._v("流量突增")]),t._v(" "),a("li",[t._v("缓存集中失效")]),t._v(" "),a("li",[t._v("线程同步调用")]),t._v(" "),a("li",[t._v("程序bug")]),t._v(" "),a("li",[t._v("服务器故障")]),t._v(" "),a("li",[t._v("数据库压力")])]),t._v(" "),a("p",[t._v("解决方案：")])]),t._v(" "),a("h2",{attrs:{id:"mysql读写分离"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql读写分离"}},[t._v("#")]),t._v(" MySQL读写分离")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("blockquote",[a("p",[t._v("有没有做MySQL读写分离？如何实现mysql的读写分离？MySQL主从复制原理？")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("MySQL读写分离")]),t._v(" "),a("ul",[a("li",[t._v("通过MyCat配置schema.xml，添加writeHost 和readHost 相关配置。")])])]),t._v(" "),a("li",[a("p",[t._v("MySQL主从复制原理")]),t._v(" "),a("ul",[a("li",[t._v("第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。")]),t._v(" "),a("li",[t._v("第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。")]),t._v(" "),a("li",[t._v("第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。")])])]),t._v(" "),a("li",[a("p",[t._v("MySQL支持的复制类型")])]),t._v(" "),a("li",[a("p",[t._v("基于语句的复制：在主服务器上执行的SQL语句，在从服务器上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。一旦发现没法精确复制时，会自动选着基于行的复制。")])]),t._v(" "),a("li",[a("p",[t._v("基于行的复制：把改变的内容复制过去，而不是把命令在从服务器上执行一遍。 从mysql5.0开始支持。")])]),t._v(" "),a("li",[a("p",[t._v("混合类型的复制: 默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。")])])])]),t._v(" "),a("h2",{attrs:{id:"单例模式的双重检查模式不安全实现的原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单例模式的双重检查模式不安全实现的原因"}},[t._v("#")]),t._v(" 单例模式的双重检查模式不安全实现的原因")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("重排序的问题")])]),t._v(" "),a("h2",{attrs:{id:"请概述aqs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请概述aqs"}},[t._v("#")]),t._v(" 请概述AQS")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("AQS（Abstract Queue Synchronized），异步抽象队列")])]),t._v(" "),a("h2",{attrs:{id:"死锁与活锁的区别，死锁与饥饿的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#死锁与活锁的区别，死锁与饥饿的区别"}},[t._v("#")]),t._v(" 死锁与活锁的区别，死锁与饥饿的区别")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("死锁： 是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。死锁发生的四个条件如下，")]),t._v(" "),a("ul",[a("li",[t._v("互斥条件")]),t._v(" "),a("li",[t._v("请求和保持条件")]),t._v(" "),a("li",[t._v("不剥夺条件")]),t._v(" "),a("li",[t._v("环路等待条件")])])]),t._v(" "),a("li",[a("p",[t._v("活锁：是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。")])]),t._v(" "),a("li",[a("p",[t._v("饥饿：是指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求......，T2可能永远等待。(ReentrantLock可以设置公平锁)")])])])]),t._v(" "),a("h2",{attrs:{id:"说几条你遵循的多线程最佳实践"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说几条你遵循的多线程最佳实践"}},[t._v("#")]),t._v(" 说几条你遵循的多线程最佳实践")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[t._v("给你的线程起个有意义的名字。")]),t._v(" "),a("li",[t._v("多用同步类少用wait 和 notify。")]),t._v(" "),a("li",[t._v("多用并发集合少用同步集合。")])])]),t._v(" "),a("h2",{attrs:{id:"什么是cap理论，和base理论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是cap理论，和base理论"}},[t._v("#")]),t._v(" 什么是cap理论，和BASE理论")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[a("code",[t._v("cap理论")]),t._v("\n一致性（Consistency）、可用性（Availability）、分区容忍性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。")]),t._v(" "),a("ul",[a("li",[t._v("一致性：在分布式系统中的所有数据备份，在同一时刻是否同样的值。")]),t._v(" "),a("li",[t._v("可用性：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。")]),t._v(" "),a("li",[t._v("分区容忍性：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。")])]),t._v(" "),a("p",[a("code",[t._v("BASE理论")]),t._v("\n核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。")]),t._v(" "),a("ul",[a("li",[t._v("Basically Available（基本可用）")]),t._v(" "),a("li",[t._v("Soft state（软状态）")]),t._v(" "),a("li",[t._v("Eventually consistent（最终一致性）")])])]),t._v(" "),a("h2",{attrs:{id:"说说你了解的几种分布式事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说说你了解的几种分布式事务"}},[t._v("#")]),t._v(" 说说你了解的几种分布式事务")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[t._v("2PC协议")]),t._v(" "),a("li",[t._v("3PC协议")]),t._v(" "),a("li",[t._v("补偿事务(TCC)，针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。")]),t._v(" "),a("li",[t._v("MQ事务消息，实现了最终一致性，不需要依赖本地数据库事务。")]),t._v(" "),a("li",[t._v("LCN实现，服务消费方加注解 @TxcTransaction。")])])]),t._v(" "),a("h2",{attrs:{id:"你认为自身的优势在哪"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#你认为自身的优势在哪"}},[t._v("#")]),t._v(" 你认为自身的优势在哪 "),a("Badge",{attrs:{text:"三面",type:"warning"}})],1),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("略......")])]),t._v(" "),a("h2",{attrs:{id:"如何同一个似乎总是不能按时完成工作的员工一起工作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何同一个似乎总是不能按时完成工作的员工一起工作"}},[t._v("#")]),t._v(" 如何同一个似乎总是不能按时完成工作的员工一起工作")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("略......")])]),t._v(" "),a("h2",{attrs:{id:"你怎样在计划中运用新技术"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#你怎样在计划中运用新技术"}},[t._v("#")]),t._v(" 你怎样在计划中运用新技术")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("略......")])]),t._v(" "),a("h2",{attrs:{id:"为什么离职"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么离职"}},[t._v("#")]),t._v(" 为什么离职"),a("Badge",{attrs:{text:"四面",type:"warning"}})],1),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("略......")])]),t._v(" "),a("h2",{attrs:{id:"有没有更好的机会"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有没有更好的机会"}},[t._v("#")]),t._v(" 有没有更好的机会")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("略......")])]),t._v(" "),a("h2",{attrs:{id:"会不会选择京东，选择京东原因是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#会不会选择京东，选择京东原因是什么"}},[t._v("#")]),t._v(" 会不会选择京东，选择京东原因是什么")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("略......")])])])}),[],!1,null,null,null);s.default=r.exports}}]);