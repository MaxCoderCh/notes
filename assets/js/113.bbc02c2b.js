(window.webpackJsonp=window.webpackJsonp||[]).push([[113],{223:function(t,s,a){"use strict";a.r(s);var e=a(0),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"头条面试题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#头条面试题"}},[t._v("#")]),t._v(" 头条面试题")]),t._v(" "),a("Badge",{attrs:{text:"高级JAVA",type:"primary"}}),t._v(" "),a("h2",{attrs:{id:"说说-arraylist，linkedlist-的差别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说说-arraylist，linkedlist-的差别"}},[t._v("#")]),t._v(" 说说 ArrayList，LinkedList 的差别"),a("Badge",{attrs:{text:"一面",type:"warning"}})],1),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[t._v("ArrayList数据结构是数组，LinkedList数据结构是链表。")]),t._v(" "),a("li",[t._v("对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。")]),t._v(" "),a("li",[t._v("对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。")]),t._v(" "),a("li",[t._v("ArrayList支持动态扩容默认原容量的1.5倍，LinkedList是链表并且实现了栈和队列的相关方法，不存在扩容问题。")])])]),t._v(" "),a("h2",{attrs:{id:"如何优化链表链表的查询速度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何优化链表链表的查询速度"}},[t._v("#")]),t._v(" 如何优化链表链表的查询速度")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("红黑树")])]),t._v(" "),a("h2",{attrs:{id:"为何jdk选择快速排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为何jdk选择快速排序"}},[t._v("#")]),t._v(" 为何JDK选择快速排序")]),t._v(" "),a("blockquote",[a("p",[t._v("快排、堆排和归并都是O(nlog n)的算法，为何JDK选择快速排序？")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("堆排序每次取一个最大值和堆底部的数据交换，重新筛选堆，归并排序也是不断拆分，都做了许多无用功。\n快排的最坏时间虽然复杂度高，但是在统计意义上，这种数据出现的概率极小，而堆排序过程里的交换跟快排过程里的交换虽然都是常量时间，但是常量时间差很多。\n因此从数据规模增长的维度来说，快排效果总体来说最高。")])]),t._v(" "),a("h2",{attrs:{id:"如何从十万大小的数据集中找出最大10个元素"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何从十万大小的数据集中找出最大10个元素"}},[t._v("#")]),t._v(" 如何从十万大小的数据集中找出最大10个元素")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("算法问题，top K的问题，采用堆排序")])]),t._v(" "),a("h2",{attrs:{id:"jdk1-8中hashmap做了怎样的改进"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jdk1-8中hashmap做了怎样的改进"}},[t._v("#")]),t._v(" JDK1.8中HashMap做了怎样的改进")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("针对链表长度超过8，转存为红黑树结构，提高查询效率。")])]),t._v(" "),a("h2",{attrs:{id:"为什么hashmap不一直使用红黑树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么hashmap不一直使用红黑树"}},[t._v("#")]),t._v(" 为什么HashMap不一直使用红黑树")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("红黑树本身的存储过程算法比较复杂，开销也比较大，数量少的场景不适合红黑树。")])]),t._v(" "),a("h2",{attrs:{id:"面向对象的特征有哪些方面"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象的特征有哪些方面"}},[t._v("#")]),t._v(" 面向对象的特征有哪些方面")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("继承、抽象、多态")])]),t._v(" "),a("h2",{attrs:{id:"string-和stringbuffer，stringbuilder-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-和stringbuffer，stringbuilder-的区别"}},[t._v("#")]),t._v(" String 和StringBuffer，StringBuilder 的区别")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("blockquote",[a("p",[t._v("运算速度比较（通常情况下）：StringBuilder > StringBuffer > String")])]),t._v(" "),a("ul",[a("li",[t._v("String：适用于少量的字符串操作。")]),t._v(" "),a("li",[t._v("StringBuilder：适用于单线程下在字符串缓冲区进行大量操作。")]),t._v(" "),a("li",[t._v("StringBuffer：适用于多线程下在字符串缓冲区进行大量操作。")])])]),t._v(" "),a("h2",{attrs:{id:"说出servlet的生命周期，servlet和cgi的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说出servlet的生命周期，servlet和cgi的区别"}},[t._v("#")]),t._v(" 说出Servlet的生命周期，Servlet和CGI的区别")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[a("strong",[t._v("Servlet的生命周期")])]),t._v(" "),a("ul",[a("li",[t._v("1、加载")]),t._v(" "),a("li",[t._v("2、实例化")]),t._v(" "),a("li",[t._v("3、初始化")]),t._v(" "),a("li",[t._v("4、处理请求")]),t._v(" "),a("li",[t._v("5、销毁")])]),t._v(" "),a("p",[a("strong",[t._v("Servlet与cgi的区别")])]),t._v(" "),a("ul",[a("li",[t._v("Servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。")])])]),t._v(" "),a("h2",{attrs:{id:"abstract-class和interface有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract-class和interface有什么区别"}},[t._v("#")]),t._v(" abstract class和interface有什么区别")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[t._v("1.抽象类可以有构造方法，接口中不能有构造方法。")]),t._v(" "),a("li",[t._v("2.抽象类中可以有普通成员变量，接口中没有普通成员变量")]),t._v(" "),a("li",[t._v("3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。")]),t._v(" "),a("li",[a("ol",{attrs:{start:"4"}},[a("li",[t._v("抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然 eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"5"}},[a("li",[t._v("抽象类中可以包含静态方法，接口中不能包含静态方法")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"6"}},[a("li",[t._v("抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。")])])])])]),t._v(" "),a("h2",{attrs:{id:"为什么tcp握手需要三次"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么tcp握手需要三次"}},[t._v("#")]),t._v(" 为什么TCP握手需要三次  "),a("Badge",{attrs:{text:"二面",type:"warning"}})],1),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("通常来说TCP只需要二次就可以相互之间行进通信了。")]),t._v(" "),a("ul",[a("li",[t._v("第一次： A要发送一条建立连接的消息告诉B咱两要通信了。")]),t._v(" "),a("li",[t._v("第二次： B收到这个消息后，要回复A一个确认消息。")])]),t._v(" "),a("p",[t._v("上面两步（两次握手）做完了，两人才就能够通信，但是由于网络通讯不稳定的原因，为了避免CPU等资源的等待耗时浪费，所以需要 三次握手，即A还需要发送一次确认收到B的信息。")]),t._v(" "),a("ul",[a("li",[t._v("第三次：A发送一次确认收到B的信息给B。")])])]),t._v(" "),a("h2",{attrs:{id:"tcp的四次挥手中为什么有time-wait状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp的四次挥手中为什么有time-wait状态"}},[t._v("#")]),t._v(" TCP的四次挥手中为什么有TIME_WAIT状态")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("网络是不可靠的，有可能最后一个ACK(Acknowledge character，确认字符)丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。")])]),t._v(" "),a("h2",{attrs:{id:"tcp协议本身会导致什么样的安全问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp协议本身会导致什么样的安全问题"}},[t._v("#")]),t._v(" TCP协议本身会导致什么样的安全问题")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[t._v("第一，依靠IP源地址来通信验证是既不可靠的。")]),t._v(" "),a("li",[t._v("第二，序列号的设定也是不安全的。一定要让序列号是不容易被他人获知的，即使是本机的使用者。")])]),t._v(" "),a("p",[t._v("在互联网中，一些控制机制看似可以保证通信的完整性，但是并不能保证通信的安全性，所以在使用的时候需要验证，加密和信任系统等多维度的保障，这样才能不被攻击者利用。")])]),t._v(" "),a("h2",{attrs:{id:"对java接口代理模式的实现原理的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对java接口代理模式的实现原理的理解"}},[t._v("#")]),t._v(" 对Java接口代理模式的实现原理的理解")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[t._v("1、为接口创建代理类的字节码文件")]),t._v(" "),a("li",[t._v("2、使用ClassLoader将字节码文件加载到JVM")]),t._v(" "),a("li",[t._v("3、创建代理类实例对象，执行对象的目标方法")])])]),t._v(" "),a("h2",{attrs:{id:"mybatis用了什么设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mybatis用了什么设计模式"}},[t._v("#")]),t._v(" Mybatis用了什么设计模式")]),t._v(" "),a("blockquote",[a("p",[t._v("Mybatis打开调试模式之后，能打印sql语句等信息，怎么实现的？用了什么设计模式？")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")])]),t._v(" "),a("h2",{attrs:{id:"spring在bean创建过程中是如何解决循环依赖的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring在bean创建过程中是如何解决循环依赖的"}},[t._v("#")]),t._v(" Spring在Bean创建过程中是如何解决循环依赖的")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("Spring的bean循环依赖只能解决在单例模式下基于set/get注入bean的场景，默认使用三级缓存解决。")])]),t._v(" "),a("h2",{attrs:{id:"spring-mvc-运行流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc-运行流程"}},[t._v("#")]),t._v(" Spring MVC 运行流程")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("1、  用户发送请求至前端控制器DispatcherServlet。")])]),t._v(" "),a("li",[a("p",[t._v("2、  DispatcherServlet收到请求调用HandlerMapping处理器映射器。")])]),t._v(" "),a("li",[a("p",[t._v("3、  处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。")])]),t._v(" "),a("li",[a("p",[t._v("4、  DispatcherServlet调用HandlerAdapter处理器适配器。")])]),t._v(" "),a("li",[a("p",[t._v("5、  HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。")])]),t._v(" "),a("li",[a("p",[t._v("6、  Controller执行完成返回ModelAndView。")])]),t._v(" "),a("li",[a("p",[t._v("7、  HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。")])]),t._v(" "),a("li",[a("p",[t._v("8、  DispatcherServlet将ModelAndView传给ViewReslover视图解析器。")])]),t._v(" "),a("li",[a("p",[t._v("9、  ViewReslover解析后返回具体View。")])]),t._v(" "),a("li",[a("p",[t._v("10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。")])]),t._v(" "),a("li",[a("p",[t._v("11、 DispatcherServlet响应用户。")])])])]),t._v(" "),a("h2",{attrs:{id:"beanfactory和applicationcontext的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beanfactory和applicationcontext的区别"}},[t._v("#")]),t._v(" BeanFactory和ApplicationContext的区别")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("BeanFactory：是Spring里面最低层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能；")])]),t._v(" "),a("li",[a("p",[t._v("ApplicationContext：应用上下文，继承BeanFactory接口，它是Spring的一各更高级的容器，提供了更多的有用的功能；")]),t._v(" "),a("ul",[a("li",[a("ol",[a("li",[t._v("国际化（MessageSource）")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[t._v("访问资源，如URL和文件（ResourceLoader）")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"3"}},[a("li",[t._v("载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"4"}},[a("li",[t._v("消息发送、响应机制（ApplicationEventPublisher）")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"5"}},[a("li",[t._v("AOP（拦截器）")])])])])])])]),t._v(" "),a("h2",{attrs:{id:"如何对数据库如何进行垂直拆分或水平拆分的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何对数据库如何进行垂直拆分或水平拆分的"}},[t._v("#")]),t._v(" 如何对数据库如何进行垂直拆分或水平拆分的")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")])]),t._v(" "),a("h2",{attrs:{id:"什么是幂等性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是幂等性"}},[t._v("#")]),t._v(" 什么是幂等性")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")])]),t._v(" "),a("h2",{attrs:{id:"解释柔性事务，分布式环境下为何要放弃传统事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解释柔性事务，分布式环境下为何要放弃传统事务"}},[t._v("#")]),t._v(" 解释柔性事务，分布式环境下为何要放弃传统事务")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")])]),t._v(" "),a("h2",{attrs:{id:"实现分布式session的过程是怎样的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现分布式session的过程是怎样的"}},[t._v("#")]),t._v(" 实现分布式Session的过程是怎样的")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")])]),t._v(" "),a("h2",{attrs:{id:"jvm中存在哪些引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm中存在哪些引用"}},[t._v("#")]),t._v(" JVM中存在哪些引用")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[a("ol",[a("li",[t._v("强引用（Strong Reference）\n在代码中普遍使用的，如果一个对象具有强引用，则无论在什么情况下，GC都不会回收被引用的对象。当内存空间不足时，JAVA虚拟机宁可抛出OutOfMemoryError终止应用程序也不会回收具有强引用的对象。")])])])]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),t._v(" person"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("ul",[a("li",[a("ol",{attrs:{start:"2"}},[a("li",[t._v("软引用（Soft Reference）\n表示一个对象处在有用但非必须的状态。如果一个对象具有软引用，在内存空间充足时，GC就不会回收该对象；当内存空间不足时，GC会回收该对象的内存（回收发生在OutOfMemoryError之前）。")])])])]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),t._v(" person"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SoftReference")]),t._v(" sr"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SoftReference")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("person"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("ul",[a("li",[a("ol",{attrs:{start:"3"}},[a("li",[t._v("弱引用（Weak Reference）\n用来描述非必须的对象。它类似软引用，但是强度比软引用更弱一些：弱引用具有更短的生命.GC在扫描的过程中，一旦发现只具有被弱引用关联的对象，都会回收掉被弱引用关联的对象。换言之，无论当前内存是否紧缺，GC都将回收被弱引用关联的对象。")])])])]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),t._v(" person"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("WeakReference")]),t._v(" wr"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("WeakReference")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("person"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("ul",[a("li",[a("ol",{attrs:{start:"4"}},[a("li",[t._v("虚引用（Phantom Reference）\n虚引等同于没有引用，这意味着在任何时候都可能被GC回收，设置虚引用的目的是为了被虚引用关联的对象在被垃圾回收器回收时，能够收到一个系统通知。（被用来跟踪对象被GC回收的活动）虚引用和弱引用的区别在于：虚引用在使用时必须和引用队列（ReferenceQueue）联合使用，其在GC回收期间的活动如下：")])])])]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReferenceQueue")]),t._v(" queue"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReferenceQueue")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PhantomReference")]),t._v(" pr"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PhantomReference")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("object"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("queue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])]),t._v(" "),a("h2",{attrs:{id:"双亲委派模型是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派模型是什么"}},[t._v("#")]),t._v(" 双亲委派模型是什么")]),t._v(" "),a("blockquote",[a("p",[t._v("请简单描述下双亲委派模型？为何Java推荐使用这种模型？JDBC是双亲委派模型？Tomcat中是双亲委派模型吗？")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[t._v("如果一个类加载器收到了加载某个类的请求，则该类加载器并不会去加载该类，而是把这个请求委派给父类加载器，每一个层次的类加载器都是如此，因此所有的类加载请求最终都会传送到顶端的启动类加载器；只有当父类加载器在其搜索范围内无法找到所需的类，并将该结果反馈给子类加载器，子类加载器会尝试去自己加载。")])])]),t._v(" "),a("blockquote",[a("p",[t._v("JDBC为什么要破坏双亲委派模型的？")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("在JDBC 4.0之后实际上我们不需要再调用Class.forName来加载驱动程序了，我们只需要把驱动的jar包放到工程的类加载路径里，那么驱动就会被自动加载。\n这个自动加载采用的技术叫做SPI，数据库驱动厂商也都做了更新。可以看一下jar包里面的META-INF/services目录，里面有一个java.sql.Driver的文件，文件里面包含了驱动的全路径名。")])]),t._v(" "),a("blockquote",[a("p",[t._v("Tomcat如何破坏双亲委派模型的？")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[t._v("每个Tomcat的webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器。")]),t._v(" "),a("li",[t._v("对于各个 中的 和 ，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源。")]),t._v(" "),a("li",[t._v("使用单独的 去装载 自身的类库，以免其他恶意或无意的破坏；")])])]),t._v(" "),a("h2",{attrs:{id:"hotspot中的堆为什么要分为新生代和老年代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hotspot中的堆为什么要分为新生代和老年代"}},[t._v("#")]),t._v(" HotSpot中的堆为什么要分为新生代和老年代")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("方便垃圾回收")])]),t._v(" "),a("h2",{attrs:{id:"cms收集器有哪些特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cms收集器有哪些特点"}},[t._v("#")]),t._v(" CMS收集器有哪些特点")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("CMS（Concurrent Mark Sweep）收集器是一种以获取最短停顿时间为目标的收集器，CMS收集器采用标记--清除算法，运行在老年代。")]),t._v(" "),a("ul",[a("li",[t._v("特点：响应时间优先，减少垃圾收集停顿时间")]),t._v(" "),a("li",[t._v("适应场景：服务器、电信领域等。")]),t._v(" "),a("li",[t._v("通过JVM参数 -XX:+UseConcMarkSweepGC设置")])])]),t._v(" "),a("h2",{attrs:{id:"如何实现分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何实现分布式锁"}},[t._v("#")]),t._v(" 如何实现分布式锁 "),a("Badge",{attrs:{text:"三面",type:"warning"}})],1),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")])]),t._v(" "),a("h2",{attrs:{id:"如何保证redis和mysql数据一致"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何保证redis和mysql数据一致"}},[t._v("#")]),t._v(" 如何保证redis和mysql数据一致")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")])]),t._v(" "),a("h2",{attrs:{id:"如何解决缓存击穿问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何解决缓存击穿问题"}},[t._v("#")]),t._v(" 如何解决缓存击穿问题")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")])]),t._v(" "),a("h2",{attrs:{id:"如何实现并发限流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何实现并发限流"}},[t._v("#")]),t._v(" 如何实现并发限流")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")])]),t._v(" "),a("h2",{attrs:{id:"请概述volatile关键字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请概述volatile关键字"}},[t._v("#")]),t._v(" 请概述volatile关键字")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[t._v("volatile保证变量可见性。")]),t._v(" "),a("li",[t._v("缓存一致性协议。")]),t._v(" "),a("li",[t._v("有序性。")])])]),t._v(" "),a("h2",{attrs:{id:"synchronized的实现原理是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#synchronized的实现原理是什么"}},[t._v("#")]),t._v(" synchronized的实现原理是什么")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")])]),t._v(" "),a("h2",{attrs:{id:"说说-dubbo-服务暴露的过程（发布订阅）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说说-dubbo-服务暴露的过程（发布订阅）"}},[t._v("#")]),t._v(" 说说 Dubbo 服务暴露的过程（发布订阅）")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")])]),t._v(" "),a("h2",{attrs:{id:"zk分布式锁有几种实现方式？各自的优缺点是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zk分布式锁有几种实现方式？各自的优缺点是什么"}},[t._v("#")]),t._v(" ZK分布式锁有几种实现方式？各自的优缺点是什么")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")])])],1)}),[],!1,null,null,null);s.default=r.exports}}]);