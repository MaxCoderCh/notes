(window.webpackJsonp=window.webpackJsonp||[]).push([[121],{205:function(s,t,a){"use strict";a.r(t);var n=a(0),e=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"java-基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-基础"}},[s._v("#")]),s._v(" Java 基础")]),s._v(" "),a("Badge",{attrs:{text:"Java面试题",type:"warning"}}),s._v(" "),a("h2",{attrs:{id:"实例化对象有哪些方式？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实例化对象有哪些方式？"}},[s._v("#")]),s._v(" 实例化对象有哪些方式？")]),s._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[s._v("参考答案")]),s._v(" "),a("ul",[a("li",[s._v("① 最常用的直接 "),a("code",[s._v("new()")]),s._v("的方式创建；")])]),s._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("A")]),s._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("A")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("ul",[a("li",[s._v("② 用"),a("code",[s._v("clone")]),s._v("方法创建， 需要类实现"),a("code",[s._v("Cloneable")]),s._v(" 接口；")])]),s._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("A")]),s._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("A")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("B")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("clone")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" \n")])])]),a("ul",[a("li",[s._v("③ 用"),a("code",[s._v("Class.forName")]),s._v("方法获取类，在调用类的"),a("code",[s._v("newinstance()")]),s._v("反射机制创建；")])]),s._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Class")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("?")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" cls "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Class")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("forName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"com.cn.A"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("A")]),s._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("A")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("cls"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("newInstance")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("ul",[a("li",[s._v("④ 用"),a("code",[s._v("Objenesis")]),s._v("，Objenesis是一个Java的库，主要用来创建特定的对象。即便没有空的构造函数也可以创建对象。")])]),s._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Objenesis")]),s._v(" objenesis "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("ObjenesisStd")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("A")]),s._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" objenesis"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("newInstance")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("A")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("ul",[a("li",[s._v("⑤ 使用 "),a("code",[s._v("SpringObjenesis")]),s._v("，这是Spring对"),a("code",[s._v("Objenesis")]),s._v("接口的一个实现。由Spring4.2之后提供的(ObjenesisCglibAopProxy在 Spring4.0就有了)")])]),s._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Objenesis")]),s._v(" objenesis "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("SpringObjenesis")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("A")]),s._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" objenesis"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("newInstance")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("A")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])])]),s._v(" "),a("div",{staticClass:"warning custom-block"},[a("p",{staticClass:"custom-block-title"},[s._v("扩展阅读")]),s._v(" "),a("p",[s._v("Objenesis主要应用场景：")]),s._v(" "),a("ul",[a("li",[s._v("序列化，远程调用和持久化 -对象需要实例化并存储为到一个特殊的状态，而没有调用代码")]),s._v(" "),a("li",[s._v("代理，AOP库和Mock对象 -类可以被子类继承而子类不用担心父类的构造器。")]),s._v(" "),a("li",[s._v("容器框架 -对象可以以非标准的方式被动态实例化（比如Spring就是容器框架）")])])]),s._v(" "),a("h2",{attrs:{id:"instanceof、isinstance、isassignablefrom区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#instanceof、isinstance、isassignablefrom区别"}},[s._v("#")]),s._v(" instanceof、isInstance、isAssignableFrom区别")]),s._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[s._v("参考答案")]),s._v(" "),a("ul",[a("li",[a("p",[a("code",[s._v("instanceof")]),s._v("运算符 只被用于对象引用变量，检查左边的被测试对象 是不是 右边类或接口的 实例化。如果被测对象是null值，则测试结果总是false。")]),s._v(" "),a("ul",[a("li",[s._v("伪代码：自身实例或子类实例 instanceof 自身类  返回true")]),s._v(" "),a("li",[s._v('例：String s=new String("javaisland");')]),s._v(" "),a("li",[s._v("例：System.out.println(s instanceof String); //true")])])]),s._v(" "),a("li",[a("p",[s._v("Class类的"),a("code",[s._v("isInstance(Object obj)")]),s._v("方法，"),a("code",[s._v("obj")]),s._v("是被测试的对象，如果"),a("code",[s._v("obj")]),s._v("是调用这个方法的class或接口 的实例，则返回true。这个方法是instanceof运算符的动态等价。")]),s._v(" "),a("ul",[a("li",[s._v("伪代码：自身类.class.isInstance(自身实例或子类实例)  返回true")]),s._v(" "),a("li",[s._v('例：String s=new String("javaisland");')]),s._v(" "),a("li",[s._v("例：System.out.println(String.class.isInstance(s)); //true")])])]),s._v(" "),a("li",[a("p",[s._v("Class类的"),a("code",[s._v("isAssignableFrom(Class cls)")]),s._v("方法，如果调用这个方法的class或接口 与 参数cls表示的类或接口相同，或者是参数cls表示的类或接口的父类，则返回true。")]),s._v(" "),a("ul",[a("li",[s._v("伪代码：自身类.class.isAssignableFrom(自身类或子类.class)  返回 true")]),s._v(" "),a("li",[s._v("例：System.out.println(ArrayList.class.isAssignableFrom(Object.class));  //false")]),s._v(" "),a("li",[s._v("例：System.out.println(Object.class.isAssignableFrom(ArrayList.class));  //true")])])])])]),s._v(" "),a("h2",{attrs:{id:"new-string-和-tostring-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new-string-和-tostring-的区别"}},[s._v("#")]),s._v(" new String() 和 toString() 的区别")]),s._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[s._v("参考答案")]),s._v(" "),a("ul",[a("li",[a("code",[s._v("toString()")]),s._v(" 是调用了Object 对象类的 "),a("code",[s._v("toString()")]),s._v(" 方法，默认返回当前对象(c)的内存地址即"),a("code",[s._v("hashCode")]),s._v("。也就是"),a("code",[s._v("[class name]@[hashCode]")]),s._v("格式，如："),a("code",[s._v("[B@312b1dae")]),s._v("。")]),s._v(" "),a("li",[s._v("new String(para)是根据para是一个字节数组，使用Java虚拟机默认的编码格式，将这个字节数组decode为对应的字符，返回的是真实的值。")])]),s._v(" "),a("p",[s._v("该问题发生在使用Socket读取客户端的字节流，把"),a("code",[s._v("bytes.toString()")]),s._v("却输出了"),a("code",[s._v("hashCode")]),s._v("值，而用"),a("code",[s._v("new String(bytes)")]),s._v("则正确的打出了值。")])]),s._v(" "),a("h2",{attrs:{id:"如何理解java关键字this"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何理解java关键字this"}},[s._v("#")]),s._v(" 如何理解Java关键字this")]),s._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[s._v("参考答案")]),s._v(" "),a("ul",[a("li",[s._v("首先，this关键字必须放在非静态方法里面。")]),s._v(" "),a("li",[s._v("可以使用this关键字引用成员变量。")]),s._v(" "),a("li",[s._v("使用this关键字在自身构造方法内部引用其它构造方法。")]),s._v(" "),a("li",[s._v("使用this关键字代表自身类的对象。")]),s._v(" "),a("li",[s._v("使用this关键字引用成员方法。")])])]),s._v(" "),a("div",{staticClass:"warning custom-block"},[a("p",{staticClass:"custom-block-title"},[s._v("this关键字是一个对象的默认引用。作为对象的默认引用，有两种情形：")]),s._v(" "),a("ol",[a("li",[s._v("在"),a("code",[s._v("构造器")]),s._v("中，引用"),a("code",[s._v("该构造器执行初始化的")]),s._v("对象。")]),s._v(" "),a("li",[s._v("在"),a("code",[s._v("方法")]),s._v("中，引用"),a("code",[s._v("调用该方法的")]),s._v("对象。")])])]),s._v(" "),a("h2",{attrs:{id:"构造方法的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构造方法的作用"}},[s._v("#")]),s._v(" 构造方法的作用")]),s._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[s._v("参考答案")]),s._v(" "),a("ul",[a("li",[s._v("首先每个类都有一个无参数的默认构造函数。这也是为什么有些类即便没有写构造方法也可以通过new来实例化。")]),s._v(" "),a("li",[s._v("为了初始化成员属性，而不是初始化对象，初始化对象是通过new关键字实现的。")]),s._v(" "),a("li",[s._v("通过new调用构造方法初始化对象，编译时根据参数签名来检查构造函数。")]),s._v(" "),a("li",[s._v("创建子类对象会调用父类构造方法但不会创建父类对象，只是调用父类构造方法初始化父类成员属性；")])])]),s._v(" "),a("div",{staticClass:"warning custom-block"},[a("p",{staticClass:"custom-block-title"},[s._v("扩展阅读")]),s._v(" "),a("blockquote",[a("p",[s._v("构造器中一定不要创建自身的实例，否则会造成调用栈溢出错误。")])]),s._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" a\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  a _a "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    _a "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    a _b "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),a("p",[s._v("以上三种情况都会造成栈溢出，会造成一个无穷递归的调用栈。")])]),s._v(" "),a("div",{staticClass:"danger custom-block"},[a("p",{staticClass:"custom-block-title"},[s._v("注意事项")]),s._v(" "),a("blockquote",[a("p",[s._v("继承中的构造方法，有下面这些规则需要遵守")])]),s._v(" "),a("ul",[a("li",[s._v("1.子类的构造过程中必须调用其父类的构造方法")]),s._v(" "),a("li",[s._v("2.子类可以在自己的构造方法中使用super(参数列表)调用父类的构造方法")]),s._v(" "),a("li",[s._v("(1).可以使用this(参数列表)调用自己这个类的其他的构造方法\n调用this的时候也调用了父类的构造方法")]),s._v(" "),a("li",[s._v("(2).如果调用了super，必须写在子类构造方法的第一行")]),s._v(" "),a("li",[s._v("(3).this也必须放在第一行,所以this,super在一个构造方法里无法同时出现\n实际上严格来讲，还是能实现的，用内部类。在内部类里面，可以使用一个this或者super")]),s._v(" "),a("li",[s._v("3.如果子类的构造方法中没有显示地调用父类构造方法，系统默认调用父类那个无参数的构造方法")]),s._v(" "),a("li",[s._v("4.如果子类构造方法中既没有显示调用父类构造方法，而父类中又没有无参的构造方法，编译会报错。\n构造器中一定不要创建自身的实例，否则会造成调用栈溢出错误。")])])])],1)}),[],!1,null,null,null);t.default=e.exports}}]);