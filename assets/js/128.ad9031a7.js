(window.webpackJsonp=window.webpackJsonp||[]).push([[128],{190:function(t,s,a){"use strict";a.r(s);var n=a(0),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"实现原理系列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现原理系列"}},[t._v("#")]),t._v(" 实现原理系列")]),t._v(" "),a("Badge",{attrs:{text:"Java面试题",type:"warning"}}),t._v(" "),a("h2",{attrs:{id:"synchronized的实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#synchronized的实现原理"}},[t._v("#")]),t._v(" "),a("code",[t._v("synchronized")]),t._v("的实现原理")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[a("code",[t._v("Synchronized")]),t._v("的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出"),a("code",[t._v("java.lang.IllegalMonitorStateException")]),t._v("的异常的原因。")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v(" monitorenter：\n  每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：\n - "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。\n - "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.\n - "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v(".如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取  monitor的所有权。\n \n monitorexit：\n  执行monitorexit的线程必须是objectref所对应的monitor的所有者。\n\n 指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。 \n")])])])]),t._v(" "),a("h2",{attrs:{id:"volatile的实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#volatile的实现原理"}},[t._v("#")]),t._v(" "),a("code",[t._v("volatile")]),t._v("的实现原理")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("在JVM底层volatile是采用“内存屏障”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：")]),t._v(" "),a("ul",[a("li",[t._v("它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；")]),t._v(" "),a("li",[t._v("它会强制将对缓存的修改操作立即写入主存；")]),t._v(" "),a("li",[t._v("如果是写操作，它会导致其他CPU中对应的缓存行无效。")])])]),t._v(" "),a("h2",{attrs:{id:"atomicinteger的实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#atomicinteger的实现原理"}},[t._v("#")]),t._v(" "),a("code",[t._v("AtomicInteger")]),t._v("的实现原理")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("AtomicInteger内部声明了一个volatile修饰的变量value用来保存实际值\n使用带参的构造函数会将入参赋值给value，无参构造器value默认值为0")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AtomicInteger")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" initialValue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" initialValue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("sun"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("misc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Unsafe")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Unsafe")]),t._v(" unsafe "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Unsafe")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getUnsafe")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" valueOffset"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    valueOffset "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" unsafe"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("objectFieldOffset\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AtomicInteger")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getDeclaredField")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"value"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Exception")]),t._v(" ex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Error")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*\n * 可以看到自增函数中调用了Unsafe函数的getAndAddInt方法\n */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("incrementAndGet")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" unsafe"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getAndAddInt")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" valueOffset"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])])]),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("扩展阅读")]),t._v(" "),a("p",[t._v("Unsafe类是在sun.misc包下，不属于Java标准。但是很多Java的基础类库，包括一些被广泛使用的高性能开发库都是基于Unsafe类开发的，比如Netty、Cassandra、Hadoop、Kafka等。Unsafe类在提升Java运行效率，增强Java语言底层操作能力方面起了很大的作用。\nUnsafe类使Java拥有了像C语言的指针一样操作内存空间的能力，同时也带来了指针的问题。过度的使用Unsafe类会使得出错的几率变大，因此Java官方并不建议使用的，官方文档也几乎没有。\n通常我们最好也不要使用Unsafe类，除非有明确的目的，并且也要对它有深入的了解才行。\nCAS也并非完美的，它会导致ABA问题，就是说，当前内存的值一开始是A，被另外一个线程先改为B然后再改为A，那么当前线程访问的时候发现是A，则认为它没有被其他线程访问过。在某些场景下这样是存在错误风险的。比如在链表中。")]),t._v(" "),a("p",[t._v("那么如何解决这个ABA问题呢，大多数情况下乐观锁的实现都会通过引入一个版本号标记这个对象，每次修改版本号都会变话，比如使用时间戳作为版本号，这样就可以很好的解决ABA问题。")])]),t._v(" "),a("h2",{attrs:{id:"hashmap的实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hashmap的实现原理"}},[t._v("#")]),t._v(" "),a("code",[t._v("HashMap")]),t._v("的实现原理")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[t._v("HashMap底层使用数组实现，数组中每一项是个单向链表，即数组和链表的结合体；当链表长度大于一定阈值时，链表转换为红黑树，这样减少链表查询时间。")]),t._v(" "),a("li",[t._v("HashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Node对象。HashMap底层采用一个Node[]数组来保存所有的key-value对，当需要存储一个Node对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Node时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Node。")])])]),t._v(" "),a("h2",{attrs:{id:"concurrenthashmap的实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap的实现原理"}},[t._v("#")]),t._v(" "),a("code",[t._v("ConcurrentHashMap")]),t._v("的实现原理")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("JDK1.7：")])]),t._v(" "),a("ul",[a("li",[t._v("ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的HashTable,它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。把一个整体分成了16个段(Segment.也就是最高支持16个线程的并发修改操作。这也是在重线程场景时减小锁的粒度从而降低锁竞争的一种方案。并且代码中大多共享变量使用volatile关键字声明，目的是第一时间获取修改的内容，性能非常好。")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("JDK1.8：")])]),t._v(" "),a("ul",[a("li",[t._v("1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现。")])])])])]),t._v(" "),a("h2",{attrs:{id:"method-invoke-实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#method-invoke-实现原理"}},[t._v("#")]),t._v(" "),a("code",[t._v("Method.invoke()")]),t._v("实现原理")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[t._v("Method.invoke()实际上并不是自己实现的反射调用逻辑，而是委托给sun.reflect.MethodAccessor来处理。首先要了解Method对象的基本构成，每个Java方法有且只有一个Method对象作为root，它相当于根对象，对用户不可见。当我们创建Method对象时，我们代码中获得的Method对象都相当于它的副本（或引用）。root对象持有一个MethodAccessor对象，所以所有获取到的Method对象都共享这一个MethodAccessor对象，因此必须保证它在内存中的可见性。")])])]),t._v(" "),a("h2",{attrs:{id:"索引的实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引的实现原理"}},[t._v("#")]),t._v(" 索引的实现原理")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[a("strong",[a("code",[t._v("BTree")]),t._v("结构")]),t._v("\n一般来说B+Tree比BTree更适合实现外存的索引结构，因为存储引擎的设计专家巧妙的利用了外存（磁盘）的存储结构，即磁盘的一个扇区是整数倍的page（页），页是存储中的一个单位，通常默认为4K，因此索引结构的节点被设计为一个页的大小，然后利用外存的“预读取”原则，每次读取的时候，把整个节点的数据读取到内存中，然后在内存中查找，已知内存的读取速度是外存读取I/O速度的几百倍，那么提升查找速度的关键就在于尽可能少的磁盘I/O，那么可以知道，每个节点中的key个数越多，那么树的高度越小，需要I/O的次数越少，因此一般来说B+Tree比BTree更快，因为B+Tree的非叶节点中不存储data，就可以存储更多的key。")])]),t._v(" "),a("h2",{attrs:{id:"mybatis的实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mybatis的实现原理"}},[t._v("#")]),t._v(" "),a("code",[t._v("MyBatis")]),t._v("的实现原理")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[t._v("MyBatis应用程序通过SqlSessionFactoryBuilder从mybatis-config.xml配置文件（也可以用Java文件配置的方式，需要添加@Configuration）中构建出SqlSessionFactory（SqlSessionFactory是线程安全的）。然后，SqlSessionFactory的实例直接开启一个SqlSession，再通过SqlSession实例获得Mapper对象并运行Mapper映射的SQL语句，完成对数据库的CRUD和事务提交，之后关闭SqlSession。\n说明：SqlSession是单线程对象，因为它是非线程安全的，是持久化操作的独享对象，类似jdbc中的Connection，底层就封装了jdbc连接。`")])]),t._v(" "),a("p",[a("strong",[t._v("MyBatis从功能架构上可以分为三层：")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。")])]),t._v(" "),a("li",[a("p",[t._v("数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。")])]),t._v(" "),a("li",[a("p",[t._v("基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。")])])])]),t._v(" "),a("h2",{attrs:{id:"arraylis实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#arraylis实现原理"}},[t._v("#")]),t._v(" "),a("code",[t._v("ArrayLis")]),t._v("实现原理")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("首页，ArrayList底层使用数组实现,集合是可变长度数组，初始容量是10，数组扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量增长大约是其容量的1.5倍，这种操作的代价很高。List接口的可变数组非同步实现，并允许包括null在内的所有元素，并且使用到了System.arraycopy方法。")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("E")]),t._v(" element"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("index "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" size "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" index "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n       "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("IndexOutOfBoundsException")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Index: "')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("index"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('", Size: "')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("size"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n       "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ensureCapacity")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("size"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Increments modCount!!")]),t._v("\n       "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("arraycopy")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("elementData"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" elementData"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" index "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" size "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n       elementData"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" element"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n       size"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])]),t._v(" "),a("h2",{attrs:{id:"字符串的工作原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符串的工作原理"}},[t._v("#")]),t._v(" 字符串的工作原理")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[t._v("当代码中出现字面量形式创建字符串对象时吗，JVM就会首先对这个字面量进行检查，，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回，否则新的字符串对象就被创建，然后将这个引用放入字符串常量池中，并返回该引用。")])])]),t._v(" "),a("h2",{attrs:{id:"jvm的工作原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm的工作原理"}},[t._v("#")]),t._v(" "),a("code",[t._v("JVM")]),t._v("的工作原理")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[a("strong",[t._v("装载")])]),t._v(" "),a("ul",[a("li",[t._v("装载过程负责找到二进制字节码并加载至"),a("code",[t._v("JVM")]),t._v("中，"),a("code",[t._v("JVM")]),t._v("通过类名、类所在的包名通过"),a("code",[t._v("ClassLoader")]),t._v("来完成类的加载，同样，也采用以上三个元素来标识一个被加载了的类：类名+包名+ClassLoader实例ID。")])]),t._v(" "),a("p",[a("strong",[t._v("链接")])]),t._v(" "),a("ul",[a("li",[t._v("链接过程负责对二进制字节码的格式进行校验、初始化装载类中的静态变量以及解析类中调用的接口、类。在完成了校验后，"),a("code",[t._v("JVM")]),t._v("初始化类中的静态变量，并将其值赋为默认值。最后一步为对类中的所有属性、方法进行验证，以确保其需要调用的属性、方法存在，以及具备应的权限（例如public、private域权限等），会造成"),a("code",[t._v("NoSuchMethodError")]),t._v("、"),a("code",[t._v("NoSuchFieldError")]),t._v("等错误信息。")])]),t._v(" "),a("p",[a("strong",[t._v("初始化")])]),t._v(" "),a("ul",[a("li",[t._v("初始化过程即为执行类中的静态初始化代码、构造器代码以及静态属性的初始化，在四种情况下初始化过程会被触发执行：调用了new；反射调用了类中的方法；子类调用了初始化；JVM启动过程中指定的初始化类。")])])]),t._v(" "),a("h2",{attrs:{id:"redis工作原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis工作原理"}},[t._v("#")]),t._v(" "),a("code",[t._v("Redis")]),t._v("工作原理")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[a("code",[t._v("Redis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库")]),t._v(",可以达到"),a("code",[t._v("100000+")]),t._v("的QPS（每秒内查询次数)。之所以QPS如此高，有以下几点：")]),t._v(" "),a("ul",[a("li",[t._v("完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；")]),t._v(" "),a("li",[t._v("数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；")]),t._v(" "),a("li",[t._v("采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；")]),t._v(" "),a("li",[t._v("使用多路I/O复用模型，非阻塞IO；")]),t._v(" "),a("li",[t._v("使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；")])])]),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("扩展")]),t._v(" "),a("ul",[a("li",[t._v("单进程多线程模型：MySQL、Memcached、Oracle（Windows版本）；")]),t._v(" "),a("li",[t._v("多进程模型：Oracle（Linux版本）；")]),t._v(" "),a("li",[t._v("Nginx有两类进程，一类称为Master进程(相当于管理进程)，另一类称为Worker进程（实际工作进程）。")])])]),t._v(" "),a("h2",{attrs:{id:"多态的实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多态的实现原理"}},[t._v("#")]),t._v(" 多态的实现原理")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("多态,就是重载和重写.重载发生在一个类中.重写发生在子类,意思就是子类重写父类相同名称的方法。\nJava 里对象方法的调用是依靠类信息里的方法表实现的。\n总体而言，当调用对象某个方法时，JVM查找该对象类的方法表以确定该方法的直接引用地址，有了地址后才真正调用该方法。")])]),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("扩展阅读")]),t._v(" "),a("p",[t._v("我们知道java程序运行时，类的相关信息放在方法区，在这些信息中有个叫方法表的区域，该表包含有该类型所定义的所有方法的信息和指向这些方法实际代码的指针。")])])],1)}),[],!1,null,null,null);s.default=e.exports}}]);