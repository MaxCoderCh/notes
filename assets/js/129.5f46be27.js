(window.webpackJsonp=window.webpackJsonp||[]).push([[129],{186:function(t,s,a){"use strict";a.r(s);var e=a(0),i=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"缓存面试题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存面试题"}},[t._v("#")]),t._v(" 缓存面试题")]),t._v(" "),a("h2",{attrs:{id:"如何理解redis的底层原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何理解redis的底层原理"}},[t._v("#")]),t._v(" 如何理解Redis的底层原理")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("Redis采用了RESP通讯协议，底层通过Socket来实现信息的传递和获取。")])]),t._v(" "),a("h2",{attrs:{id:"为什么redis是单线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么redis是单线程"}},[t._v("#")]),t._v(" 为什么Redis是单线程")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("p",[t._v("官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。")])]),t._v(" "),a("h2",{attrs:{id:"如何理解缓存穿透、缓存雪崩、缓存预热"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何理解缓存穿透、缓存雪崩、缓存预热"}},[t._v("#")]),t._v(" 如何理解缓存穿透、缓存雪崩、缓存预热")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),a("ul",[a("li",[t._v("缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。")]),t._v(" "),a("li",[t._v("如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩。")]),t._v(" "),a("li",[t._v("通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。")])])])])}),[],!1,null,null,null);s.default=i.exports}}]);