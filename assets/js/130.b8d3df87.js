(window.webpackJsonp=window.webpackJsonp||[]).push([[130],{180:function(t,n,o){"use strict";o.r(n);var c=o(0),e=Object(c.a)({},(function(){var t=this,n=t.$createElement,o=t._self._c||n;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h1",{attrs:{id:"数据库题"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#数据库题"}},[t._v("#")]),t._v(" 数据库题")]),t._v(" "),o("h1",{attrs:{id:"count-1-比-count-效率高么？"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#count-1-比-count-效率高么？"}},[t._v("#")]),t._v(" count(1) 比 count(*) 效率高么？")]),t._v(" "),o("div",{staticClass:"tip custom-block"},[o("p",{staticClass:"custom-block-title"},[t._v("参考答案")]),t._v(" "),o("p",[t._v("官网的解释：InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.")]),t._v(" "),o("p",[t._v("count 的含义：返回 SELECT 语句检索的行中 expr 的非 NULL 值的计数，到这里我们就明白了，首先它是一个聚合函数，然后对 SELECT 的结果集进行计数，但是需要参数不为 NULL。")]),t._v(" "),o("p",[t._v("count(*)")]),t._v(" "),o("p",[t._v("不关心这个返回值是否为空都会计算他的count，因为 count(1) 中的 1 是恒真表达式，那么 count(*) 还是 count(1) 都是对所有的结果集进行 count，所以他们本质上没有什么区别。")]),t._v(" "),o("p",[t._v("count(column) 也是会遍历整张表，但是不同的是它会拿到 column 的值以后判断是否为空，然后再进行累加，那么如果针对主键需要解析内容，如果是二级所以需要再次根据主键获取内容，又是一次 IO 操作，所以 count(column) 的性能肯定不如前两者。")]),t._v(" "),o("p",[t._v("如果按照效率比较的话：")]),t._v(" "),o("p",[t._v("count(*)=count(1)>count(primary key)>count(column)")])])])}),[],!1,null,null,null);n.default=e.exports}}]);