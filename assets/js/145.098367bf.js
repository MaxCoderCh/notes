(window.webpackJsonp=window.webpackJsonp||[]).push([[145],{158:function(t,e,s){"use strict";s.r(e);var a=s(0),v=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"十四-spring的事务管理-隔离级别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#十四-spring的事务管理-隔离级别"}},[t._v("#")]),t._v(" [十四] Spring的事务管理 - 隔离级别")]),t._v(" "),s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[t._v("导读")]),t._v(" "),s("blockquote",[s("p",[t._v("MySQL官方对隔离界别的定义："),s("code",[t._v("The transaction isolation level of a SQL-transaction defines the degree to which the operations on SQL-data, or schemas in that SQL-transaction are affected by the effects of and can affect operations on SQL-data or schemas in concurrent SQL-transactions")]),t._v(".")])]),t._v(" "),s("p",[t._v('大概意思就是说："一个sql事务的事务隔离级别定义的sql数据上的操作,或模式的sql事务受到的影响,会影响操作的sql数据并发sql事务或模式"。简单地说，隔离级别定义了并发事务在修改数据时的交互方式(如何相互影响的)。')]),t._v(" "),s("p",[t._v("Spring 事务中的隔离级别最终实现还是依赖数据库的，是在数据库的基础上进行了业务的包装，以便更好的和数据库结合，本身针对"),s("code",[t._v("MySQL")]),t._v("数据库中的隔离级别进行举例说明。")])]),t._v(" "),s("h2",{attrs:{id:"隔离级别的分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#隔离级别的分类"}},[t._v("#")]),t._v(" 隔离级别的分类")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("名字")]),t._v(" "),s("th",[t._v("隔离级别")]),t._v(" "),s("th",[t._v("脏读")]),t._v(" "),s("th",[t._v("不可重复读")]),t._v(" "),s("th",[t._v("幻读")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[s("strong",[t._v("读未提交")])]),t._v(" "),s("td",[s("code",[t._v("ISOLATION_READ_UNCOMMITTED")])]),t._v(" "),s("td",[t._v("会")]),t._v(" "),s("td",[t._v("会")]),t._v(" "),s("td",[t._v("会")])]),t._v(" "),s("tr",[s("td",[s("strong",[t._v("读提交")])]),t._v(" "),s("td",[s("code",[t._v("ISOLATION_READ_COMMITTED")])]),t._v(" "),s("td",[t._v("不会")]),t._v(" "),s("td",[t._v("会")]),t._v(" "),s("td",[t._v("会")])]),t._v(" "),s("tr",[s("td",[s("strong",[t._v("可重复读")])]),t._v(" "),s("td",[s("code",[t._v("ISOLATION_REPEATABLE_READ")])]),t._v(" "),s("td",[t._v("不会")]),t._v(" "),s("td",[t._v("不会")]),t._v(" "),s("td",[t._v("会")])]),t._v(" "),s("tr",[s("td",[s("strong",[t._v("串行化")])]),t._v(" "),s("td",[s("code",[t._v("ISOLATION_SERIALIZABLE")])]),t._v(" "),s("td",[t._v("不会")]),t._v(" "),s("td",[t._v("不会")]),t._v(" "),s("td",[t._v("不会")])])])]),t._v(" "),s("blockquote",[s("p",[t._v("首先可以查看MySQL数据库的默认隔离级别是"),s("code",[t._v("可重复读(RR)")])]),t._v(" "),s("p",[t._v("select @@tx_isolation;")])]),t._v(" "),s("div",{staticClass:"language-mysql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("+-----------------------+\n| @@tx_isolation \t\t|\n+-----------------------+\n| REPEATABLE-READ       |\n+-----------------------+\n")])])]),s("h2",{attrs:{id:"repeatable-read-可重复读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#repeatable-read-可重复读"}},[t._v("#")]),t._v(" REPEATABLE-READ(可重复读)")]),t._v(" "),s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[t._v("RR")]),t._v(" "),s("p",[s("strong",[t._v("可重复读（REPEATABLE-READ）")]),t._v("：一个事务在执行过程中可以看到其他事务已经提交的新插入的记录（读已经提交的，其实是读早于本事务开始且已经提交的），但是不能看到其他事务对已有记录的更新（即晚于本事务开始的），并且该事务不要求与其他事务是“可串行化”的。")]),t._v(" "),s("p",[t._v("换句话说，就是在可重复读（Repeatable Read）的隔离级别下，其他事务线程添加了"),s("code",[t._v("id=10")]),t._v("的数据并提交，那么当前线程是读取不到的，但是数据其实已经添加到了表中，也就是说如果在当前线程中再执行添加"),s("code",[t._v("id=10")]),t._v("的数据会报错，提示当前id已经存在。")])]),t._v(" "),s("h3",{attrs:{id:"示例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),s("ul",[s("li",[t._v("首先，线程A执行到"),s("code",[t._v("select * from cp_goods")]),t._v("查询操作，并没有提交")])]),t._v(" "),s("div",{staticClass:"language-mysql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("# set transaction isolation level repeatable read;\nbegin ;\nselect * from cp_goods;\n# commit ;\n")])])]),s("p",[t._v("查询结果是：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1\ttest\t100\n2\ttest1\t100\n3\ttest2\t100\n\n")])])]),s("ul",[s("li",[t._v("此时，另外一个线程B由于业务需求要对表"),s("code",[t._v("cp_goods")]),t._v("进行修改，添加一条数据并提交")])]),t._v(" "),s("div",{staticClass:"language-mysql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("# set transaction isolation level repeatable read;\nbegin ;\ninsert into cp_goods ( name, count) VALUE ( 'test3',100);\ncommit ;\n")])])]),s("ul",[s("li",[t._v("然后，回到A再执行"),s("code",[t._v("select * from cp_goods")]),t._v("，发现查询结果并没有改变，这就是可重复读。")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1\ttest\t100\n2\ttest1\t100\n3\ttest2\t100\n\n")])])]),s("ul",[s("li",[t._v("然后，A接着执行"),s("code",[t._v("commit")]),t._v("提交操作，再次执行"),s("code",[t._v("select * from cp_goods")]),t._v("，发现可以查到数据了。")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1\ttest\t100\n2\ttest1\t100\n3\ttest2\t100\n4\ttest3\t100\n\n")])])]),s("blockquote",[s("p",[t._v("在RR隔离级别下为事务设置了一个"),s("code",[t._v("一致性读视图（即快照）")]),t._v("，之后读取数据，就是根据这个快照来获取，这样，就不能看到他晚于本事务的事务对已有记录的更新，也就是为什么线程B提交后，A查询结果仍然可以保持不变。")])]),t._v(" "),s("blockquote",[s("p",[t._v("由此可见，可重复读的隔离级别下使用了"),s("code",[t._v("MVCC机制")]),t._v("，使用的是"),s("code",[t._v("Next-Key Lock")]),t._v("锁算法，"),s("code",[t._v("select")]),t._v("操作不会更新版本号，是快照读（历史版本）；"),s("code",[t._v("insert")]),t._v("、"),s("code",[t._v("update")]),t._v("和"),s("code",[t._v("delete")]),t._v("会更新版本号，是当前读（当前版本）。")])]),t._v(" "),s("div",{staticClass:"warning custom-block"},[s("p",{staticClass:"custom-block-title"},[t._v("知识点")]),t._v(" "),s("p",[t._v("MVCC（多版本并发控制），InnoDB为每行记录添加了一个版本号（系统版本号），每当修改数据时，版本号加一。在读取事务开始时，系统会给事务一个当前版本号，事务会读取版本号<=当前版本号的数据，这时就算另一个事务插入一个数据，并立马提交，新插入这条数据的版本号会比读取事务的版本号高，因此读取事务读的数据还是不会变。")])]),t._v(" "),s("h2",{attrs:{id:"read-uncommitted-读未提交"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#read-uncommitted-读未提交"}},[t._v("#")]),t._v(" READ-UNCOMMITTED(读未提交)")]),t._v(" "),s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。")])]),t._v(" "),s("h3",{attrs:{id:"示例-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#示例-2"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),s("ul",[s("li",[t._v("首先，线程A执行到"),s("code",[t._v("select * from cp_goods")]),t._v("查询")])]),t._v(" "),s("div",{staticClass:"language-mysql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("set transaction isolation level read uncommitted ;\nbegin ;\nselect * from cp_goods;\n# commit ;\n")])])]),s("p",[t._v("查询结果是：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1\ttest\t100\n2\ttest1\t100\n3\ttest2\t100\n4\ttest3\t100\n\n")])])]),s("ul",[s("li",[t._v("此时，另外一个线程B由于业务需求要对表"),s("code",[t._v("cp_goods")]),t._v("进行修改，添加并修改一条数据，没有提交")])]),t._v(" "),s("div",{staticClass:"language-mysql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("set transaction isolation level read uncommitted ;\nbegin ;\ninsert into cp_goods ( name, count) VALUE ( 'test4',100);\nupdate cp_goods  set count= count - 10 where id = 1;\n# commit ;\n")])])]),s("ul",[s("li",[t._v("然后，回到A再执行"),s("code",[t._v("select * from cp_goods")]),t._v("，发现查询读取到了B未提交的数据，这就是读未提交。")])]),t._v(" "),s("p",[t._v("查询结果是：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1\ttest\t90\n2\ttest1\t100\n3\ttest2\t100\n4\ttest3\t100\n5\ttest4\t100\n")])])]),s("h2",{attrs:{id:"read-committed-读提交"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#read-committed-读提交"}},[t._v("#")]),t._v(" READ-COMMITTED(读提交)")]),t._v(" "),s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。")])]),t._v(" "),s("h3",{attrs:{id:"示例-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#示例-3"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),s("ul",[s("li",[t._v("首先，线程A执行到"),s("code",[t._v("select * from cp_goods")]),t._v("查询")])]),t._v(" "),s("div",{staticClass:"language-mysql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("set transaction isolation level read committed ;\nbegin ;\nselect * from cp_goods;\n# commit ;\n")])])]),s("p",[t._v("查询结果是：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1\ttest\t100\n2\ttest1\t100\n3\ttest2\t100\n4\ttest3\t100\n\n")])])]),s("ul",[s("li",[t._v("此时，另外一个线程B由于业务需求要对表"),s("code",[t._v("cp_goods")]),t._v("进行修改，添加并修改一条数据，并且提交")])]),t._v(" "),s("div",{staticClass:"language-mysql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("set transaction isolation level read committed ;\nbegin ;\ninsert into cp_goods ( name, count) VALUE ( 'test5',100);\nupdate cp_goods  set count= count - 10 where id = 2;\ncommit ;\n")])])]),s("ul",[s("li",[t._v("然后，回到A再执行"),s("code",[t._v("select * from cp_goods")]),t._v("，发现查询读取到了B提交的数据，这就是读提交。")])]),t._v(" "),s("p",[t._v("查询结果是：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1\ttest\t90\n2\ttest1\t90\n3\ttest2\t100\n4\ttest3\t100\n5\ttest4\t100\n6\ttest5\t100\n\n")])])]),s("div",{staticClass:"warning custom-block"},[s("p",{staticClass:"custom-block-title"},[t._v("知识点")]),t._v(" "),s("p",[t._v("MySQL常用的两种引擎"),s("code",[t._v("MyISAM")]),t._v("和"),s("code",[t._v("InnoDB")]),t._v("，"),s("code",[t._v("MyISAM")]),t._v("默认使用表锁，"),s("code",[t._v("InnoDB")]),t._v("默认使用行锁。\n使用"),s("code",[t._v("InnoDB")]),t._v("引擎，如果筛选条件里面没有索引字段，就会锁住整张表，否则的话，锁住相应的行。")])])])}),[],!1,null,null,null);e.default=v.exports}}]);